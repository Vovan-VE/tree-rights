#!/usr/bin/perl

use strict;
use warnings;
use 5.010;

use Pod::Usage;
use File::Find;

use constant {
    VERSION_NAME   => 'tree-rights',
    VERSION_NUMBER => '0.0.0',
};
use constant {
    VERSION => VERSION_NAME . '/' . VERSION_NUMBER,
};

# подробный man программы
sub usage_man() {
    use Pod::Man;

    my $parser = Pod::Man->new(
        center  => VERSION_NAME . " Manual",
        release => VERSION_NUMBER,
    );
    if ( open(my $man, "|man -l -") ) {
        $parser->parse_from_file(__FILE__, $man);
        close $man;
        exit 0;
    }
    else {
        warn "Can't create a pipe to man tool\n";
        warn "Try to execute:  pod2man '$0' | man -l -\n";
        exit 1;
    }
}

my (%opt, %roles, @rules);

my $RE_ROLE = qr/[a-z_][-_a-z0-9]*/;

sub process_info_options() {
    pod2usage(1)
        if defined $opt{help}
    ;

    usage_man()
        if defined $opt{man}
    ;

    say(VERSION) and exit(0)
        if defined $opt{version}
    ;
}

sub load_options() {
    use Getopt::Long;

    Getopt::Long::Configure("bundling");

    %opt = (
        directory => './',
        role      => {},
        rules     => undef,
    );

    GetOptions(\%opt,
        "help|h|?",
        "man",
        "version",
        "directory|d=s",
        "role|r=s%",
        "rules|f=s",
    )
        or pod2usage(2)
    ;

    $opt{directory} .= '/' unless $opt{directory} =~ m~/$~;

    $opt{rules} //= shift @ARGV;
    $opt{rules} //= '-';
    @ARGV and pod2usage(2);
}


sub init_roles() {
    %roles = ();
    for my $role (keys %{$opt{role}}) {
        $role =~ /^$RE_ROLE$/
            or die qq(E! Bad role name: "$role"\n)
        ;

        my $who = $opt{role}->{$role};

        $who =~
        /
            (?(DEFINE)
                (?<name> [a-z_][-_a-z0-9]* )
            )
            ^
            (?<user> (?&name) )
            (?:
                :
                (?<group> (?&name) )
            )?
            $
        /x
            or die qq(E! Malformed role for "$role": $who\n)
        ;

        $roles{$role} = {
            user  => $+{user},
            group => $+{group} // $+{user},
        };
    }
}

sub read_rules() {
    my $f;
    my $fail = 0;

    if ('-' eq $opt{rules}) {
        $f = \*STDIN;
    }
    else {
        open($f, '<', $opt{rules}) or die qq(E! Unable to read "$opt{rules}": $!\n);
    }

    @rules = ();

    while (my $rule = <$f>) {
        chomp $rule;
        my ($pattern, $chown, $mode, @rest) = split(/\s+/, $rule);

        if (@rest) {
            warn qq(W! Malformed rule - too much fields: [$.] $rule\n);
            $fail = 1;
            next;
        }

        if ('' eq $pattern) {
            warn qq(W! Empty pattern: [$.] $rule\n);
            $fail = 1;
            next;
        }

        if (defined $chown) {
            if ('-' eq $chown) {
                $chown = undef;
            }
            elsif ($chown =~ /^(?:-|$RE_ROLE)(?::(?:-|$RE_ROLE))?$/) {
                my ($user, $group) = my (@whos) = split ':', $chown;
                $group //= $user;

                my $unknown = 0;
                for my $role (@whos) {
                    next unless defined $role;
                    unless (defined $roles{$role}) {
                        warn qq(W! Unknown role "$role": [$.] $rule\n);
                        $unknown = 1;
                    }
                }
                if ($unknown) {
                    $fail = 1;
                    next;
                }

                $chown = {
                    user  => $roles{$user }->{user},
                    group => $roles{$group}->{group},
                };
            }
            else {
                warn qq(W! Malformed CHOWN "$chown": [$.] $rule\n);
                $fail = 1;
                next;
            }
        }

        if (defined $mode) {
            if ('-' eq $mode) {
                $mode = undef;
            }
            elsif ($mode =~ /^[0-7]{3}$/) {
                # ok
            }
            else {
                warn qq(W! Malformed MODE "$mode": [$.] $rule\n);
                $fail = 1;
                next;
            }
        }

        push @rules, {
            pattern => $pattern,
            chown   => $chown,
            mode    => $mode,
        };
    }

    close $f unless $f == \*STDIN;

    $fail and die qq(E! Some rules are not valid\n);
}

sub perform_rights_change() {
    my $rel_pos = length($opt{directory}) - 1;
    my $process_found = sub () {
        my $file     = $_;
        my $full     = $File::Find::name;
        my $relative = substr $full, $rel_pos;

        return if -l $full;

    };

    find($process_found, $opt{directory});
}

sub do_the_work() {
    init_roles();
    read_rules();

    chdir $opt{directory} or die qq(E! Unable to CD to "$opt{directory}" - $!\n);

    perform_rights_change();
}


load_options();
process_info_options();
do_the_work();
1;

__END__;

=pod

=head1 NAME

tree-rights - a tool to change filesystem rights according to rules

=head1 SYNOPSIS

B<tree-rights> [I<options>] [--] [<FILE>]

B<tree-rights> (B<-h> | B<-?> | B<--help> | B<--man> | B<--version>)

=head1 DESCRIPTION

...

=head1 OPTIONS

=over

=item B<-d> I<path>, B<--directory=>I<path>

Path to the tree. Default is C<.>, t.i. current working directory.

=item B<-f> I<FILE>, B<--rules=>I<FILE>

File with rules. Standard input will be used if B<-f> is ommitted.
Also C<-> can be passed as I<FILE> to mean STDIN explicitly.

See also I<FILE>.

=item B<-h>, B<-?>, B<--help>

Print short help about usage and exit.

=item B<--man>

Display full man and exit.

=item B<-r> I<role>B<=>I<owner>, B<--role=>I<role>B<=>I<owner>

Declare roles to use in rules table. One B<-r> declares one role, so
multiple B<-r>s are fine.

Here I<owner> should be I<user>[B<:>I<group>]. If I<group> is ommited, then
I<user> will be used as group.

=item B<--version>

Print program version and exit.

=item I<FILE>

Same as B<-f>. Cannot be used together.

=back

=head1 AUTHORS

=over

=item i-deal Studio <mail@i-dl.ru>, <http://www.i-dl.ru/>

=item Vovan-VE <vovan-ve@yandex.ru>

=back

=cut
